\chapter{Design Patterns}

\section{Creational}
Creational design patterns are design patterns that deal with object creation
mechanisms, trying to create objects in a manner suitable to the situation. The basic form of object
creation could result in design problems or added complexity to the design. Creational design patterns
solve this problem by controlling this object creation.

\subsection{Abstract Factory}
The Abstract Factory design pattern adds another layer of abstraction to the Factory design pattern.
The Abstract Factory provides us with a framework that allows us to create families of related or
dependent objects without specifying their concrete classes. So at runtime, the abstract factory is
coupled with any desired factory which can create objects of desired type.

\section{Structural}
Structural design patterns are design patterns that ease the design by identifying a simple way to
realize relationships between entities.

\subsection{Bridge}
The Bridge design pattern allows us to separate the abstraction from the implementation, thus
allowing us to hide the implementation from the client and only providing the abstraction.
Use when:
\begin{itemize}
	\item we want run-time binding of the implementation
	\item we have a collection of related classes resulting from a coupled interface and numerous
	      implementations
	\item we want to share an implementation among multiple objects
	\item we need to map orthogonal class hierarchies
\end{itemize}

\subsection{Composite}
The composite pattern is used to group objects into tree structures to represent whole-part hierachies. This pattern lets clients treat individual objects and compositions of objects uniformly. \cite{sourcemaking}

\section{Behavioral}
In software engineering, behavioral design patterns are design patterns that identify common communication patterns between objects and realize these patterns. By doing so, these patterns increase flexibility in carrying out this communication. \cite{sourcemaking}

\subsection{Memento}
The memento pattern allows us to capture and externalise an objects state so that the object can be returned to this state later on.
Steps:
\begin{itemize}
	\item Ask originator to create and return a memento.
	\item Save the memento.
	\item Update the state of the originator.
	\item Retrieve a memento from storage.
	\item Ask originator to recreate its previous state using this memento.
\end{itemize}

\subsection{State}
The state pattern allows an object to change it's behaviour when it changes it's internal state. The main object is called the context and this is the object that keeps the state. When the state needs to be changed the state currently being ran can update that state of the context.

\subsection{Visitor}
The visitors purpose is to abstract functionality that can be applied to an aggregate hierarchy of \'Element\' objects. \cite{sourcemaking} This allows the operations to be put into their own class which stops polluting the objects class.
\begin{itemize}
	\item The visitor asks the element to accept it's visit.
	\item The element accepts and passes itself to the visitors visit method.
\end{itemize}
