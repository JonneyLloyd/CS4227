\chapter{Design Patterns}
TODO context and consequences and support for scenario.
TODO generic factory, command
TODO code snippet of Generic Factory Method, Composite, Command, State, Interceptor

\section{Creational}
Creational design patterns are design patterns that deal with object creation
mechanisms, trying to create objects in a manner suitable to the situation. The basic form of object
creation could result in design problems or added complexity to the design. Creational design patterns
solve this problem by controlling this object creation~\citep{oodesign}.

\subsection{Abstract Factory}
The Abstract Factory design pattern adds another layer of abstraction to the Factory design pattern.
The Abstract Factory provides us with a framework that allows us to create families of related or
dependent objects without specifying their concrete classes. So at runtime, the abstract factory is
coupled with any desired factory which can create objects of desired type~\citep{oodesign}.

We used the Abstract Factory to create our server and load extensions.


\begin{lstlisting}[language=Python]
class AppFactory(object):

	@staticmethod
	def create_app(config: ServerConfig) -> Flask:
	app = Flask(__name__)
	app.config.from_object(config)
	with app.app_context():
		AppFactory._load_extensions_before(app)
		AppFactory._load_controllers(app)
		AppFactory._load_extensions_after(app)
	return app

	@staticmethod
	def _load_extensions_after(app: Flask) -> None:
		api.init_app(app)
		dynamo.init_app(app)
		dynamo.create_all()
\end{lstlisting}


\subsection{Generic Factory Method}
TODO

\section{Structural}
Structural design patterns are design patterns that ease the design by identifying a simple way to
realize relationships between entities~\citep{oodesign}.


\subsection{Composite}
The composite pattern is used to group objects into tree structures to represent whole-part hierarchies. This pattern lets clients treat individual objects and compositions of objects uniformly. \cite{sourcemaking}

\subsection{Pluggable Adapter}
The pluggable adapter allows a system to be plugged in. It lets us incorporate a class into
existing systems that expected different interfaces.

We implemented the pluggable Adapter to create an abstraction layer between our application and
the chosen NoSQL database. This means that any database which supports the set of CRUD operations
defined in our interface can be used by just implementing the required hooks in the pluggable
adapter.

\begin{lstlisting}[language=Python]
class DocumentStore(ABC):

	@abstractmethod
	def _save(self, name: str, _list: List[dict]) -> None:
		...
	
	def save_pipeline(self, name: str, pipeline_memento: PipelineMemento) -> None:
		config_memento_list = self._extract_config_memento_list(pipeline_memento)
		self._save(name, config_memento_list)

class DynamoStore(DocumentStore):

	def __init__(self):
		self.store = dynamo
	
	def _save(self, name: str, _list: List[dict]) -> None:
		table = self.store.tables['mementos']
		table.put_item(Item={
			'type': name,
			'config': _list
		})
\end{lstlisting}

\section{Behavioural}
In software engineering, behavioural design patterns are design patterns that identify common communication patterns between objects and realize these patterns. By doing so, these patterns increase flexibility in carrying out this communication. \cite{sourcemaking}

\subsection{Command}
TODO

\subsection{Memento}
The memento pattern allows us to capture and externalise an objects state so that the object can be returned to this state later on.
Steps:
\begin{itemize}
	\item Ask originator to create and return a memento.
	\item Save the memento.
	\item Update the state of the originator.
	\item Retrieve a memento from storage.
	\item Ask originator to recreate its previous state using this memento.
\end{itemize}

We used the Memento design pattern to capture the pipeline state. These mementos were then stored in
a NoSQL database which allowed to us restore to such state an any stage.

\begin{lstlisting}[language=Python]
class Pipeline(PipelineBase):

	def set_memento(self, memento: PipelineMemento) -> None:
		self.config = memento.config
	
	def create_memento(self) -> PipelineMemento:
		memento = PipelineMemento()
		memento.config = self.config
		return memento
		
class PipelineMemento:

	@property
	def config(self) -> List[ConfigMemento]:
		return self._config
	
	@config.setter
	def config(self, value: List[ConfigMemento]) -> None:
		self._config = value

class ConfigMemento():

	@property
	def config(self) -> Optional[Dict[str, Any]]:
		return self._config or None
	
	@config.setter
	def config(self, value: Dict[str, Any]) -> None:
		self._config = value
\end{lstlisting}

\subsection{State}
The state pattern allows an object to change it's behaviour when it changes it's internal state. The main object is called the context and this is the object that keeps the state. When the state needs to be changed the state currently being ran can update that state of the context.

\subsection{Strategy}
Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the
algorithm vary independently from clients that use it~\citep{oodesign}

We used the Strategy design pattern to add encryption to text.


\begin{lstlisting}[language=Python]
class Encryptor(ABC):

	@abstractmethod
	def encrypt(self, text: str) -> bytes:
		...

class FernetEncryptor(Encryptor):

	def __init__(self) -> None:
		self._key = Fernet.generate_key()
		self._suite = Fernet(self._key)

	def encrypt(self, text: str) -> bytes:
		return self._suite.encrypt(text.encode())

class Encryption:

	def __init__(self, encryptor: Encryptor) -> None:
		self._encryptor = encryptor

	def encrypt(self, text: str) -> bytes:
		return self._encryptor.encrypt(text)
\end{lstlisting}

\subsection{Visitor}
The visitors purpose is to abstract functionality that can be applied to an aggregate hierarchy of \'Element\' objects. \cite{sourcemaking} This allows the operations to be put into their own class which stops polluting the objects class.
\begin{itemize}
	\item The visitor asks the element to accept it's visit.
	\item The element accepts and passes itself to the visitors visit method.
\end{itemize}

We implemented the Visitor design pattern to add functionality to our requests. We have only implemented json
requests for the time being but would intend to implement XML requests also. The visitor has the functionality
to handle this.

\begin{lstlisting}[language=Python]
class JsonVisitor(ABC):

	@abstractmethod
	@overload
	def visit(self, visitable: JsonRequest) -> str:
		...

class JsonSanitizer(JsonVisitor):

	@overload
	def visit(self, json_request: JsonRequest) -> str:
		return str(json.loads(json_request.text))

class Visitable(ABC):

	@abstractmethod
	def accept(self, visitor: JsonSanitizer) -> None:
		...
	
class JsonRequest(Visitable):
	
	def accept(self, visitor: JsonSanitizer) -> None:
		self._text = visitor.visit(self)

\end{lstlisting}

\section{Architectural}
Architectural patterns are similar to software design pattern but with a broader scope. The architectural patterns address various issues in software engineering, such as computer hardware performance limitations, high availability and minimization of a business risk. Architectural patterns have often been implemented within software frameworks such as Apache Tomcat and Glassfish.

"\textit{Architecture patterns help define the basic characteristics and behavior of an application. For example, some architecture patterns naturally lend themselves toward highly scalable applications,
whereas other architecture patterns naturally lend themselves toward applications that are highly agile.}" \citep{patterns}

\subsection{Interceptor}
The Interceptor is used for developing frameworks that can be extended transparently, allowing out-of-band services to register with the framework using predefined interfaces. The framework creates  a dispatched and context object. The client creates a concrete interceptor from the interface. The client attaches the interceptor to the dispatcher. When an event occurs in the framework it will pass the context object to the dispatcher which will iterate all registered interceptor, using the observer design pattern method. The context object is passed to the interceptor where the client can then access the internals of the framework.

\subsection{REST}
REST (Representational state transfer) or RESTful web services are a way of providing interoperability between computer systems through the Internet. For our project we used Flask-RESTful which is an extension for Flask that adds support for quickly building REST APIs. It has been combined with the abstract factory pattern to provide better flexibility, with different server configurations.

\begin{lstlisting}[language=Python]
class AppFactory(object):
    @staticmethod
    def create_app(config: ServerConfig) -> Flask:
        app = Flask(__name__)
        app.config.from_object(config)
        with app.app_context():
            AppFactory._load_extensions_before(app)
            AppFactory._load_controllers(app)
            AppFactory._load_extensions_after(app)
        return app

    @staticmethod
    def _load_extensions_before(app: Flask) -> None:
        pass

    @staticmethod
    def _load_controllers(app: Flask) -> None:
        pass

    @staticmethod
    def _load_extensions_after(app: Flask) -> None:
        api.init_app(app)
        dynamo.init_app(app)
        dynamo.create_all()
        
        
class ServerConfig:
    APP_NAME = 'Pipeline'
    APP_PORT = 80
    SECRET_KEY = os.urandom(12)
    DEBUG = False
    LOG_LEVEL = 'info'

    DATABASE_URI = None
    DATABASE_KEY = None
\end{lstlisting}

Then in the Api package we define addresses for accessing resources that are returned to the client.

\begin{lstlisting}[language=Python]
@api.route('/api/v1.0/pipeline/<str:title>')
class PipelineAPI(Resource):
    def get(self, title):
        pipeline = ManagePipeLines.get_pipeline(title)
        return {'Location': api.url_for(PipelineAPI, title= title)}, 201
\end{lstlisting}
